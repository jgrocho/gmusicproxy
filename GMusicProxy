#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Google Play Music Proxy
# "Let's stream Google Play Music using any music program"
#
# contributors:
#  - Mario Di Raimondo < mario.diraimondo (at) gmail.com >
#  - Nick Depinet < depinetnick (at) gmail.com >
#  - Adam Prato < adam.prato (at) gmail.com >
#  - Pierre Karashchuk < krchtchk (at) gmail.com >
#  - Alex Busenius
#  - Mark Gillespie < mark.gillespie (at) gmail.com >
#  - Justin Woody
#
# license: GPL v3
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

from urllib.parse import urlparse, parse_qs
from urllib.request import build_opener
from http.server import HTTPServer, BaseHTTPRequestHandler
from configparser import ConfigParser
from io import StringIO
from socketserver import ThreadingMixIn

import socket
import requests
import signal
import os
import sys
import errno
import tempfile
import netifaces
import pprint
import argparse
import xdg.BaseDirectory
import logging
import distutils.version
import threading
import gmusicapi
import gmusicapi.utils
import eyed3.id3
import random
import json
import gmusicproxyutils as gmputils
import datetime
import markdown
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from gmusicapi.exceptions import CallFailure
try:
    import daemon
except Exception:
    pass
try:
    import keyring.core as keyring
except ImportError:
    pass

# These requests require all access.
ALL_ACCESS = ['/get_all_stations', '/get_station', '/get_ifl_station', '/get_album', '/get_top_tracks_artist',
              '/get_discography_artist', '/search_id', '/get_new_station_by_id', '/get_new_station_by_search']


class MultiThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    daemon_threads = True


class GetHandler(BaseHTTPRequestHandler):

    def do_GET(self):
        self._process_request('GET', self.server.get_handlers)

    def handle_song(self, params):
        send_icy_meta = 'icy-metadata' in self.headers or params('icy-metadata', False)
        return 'id' in params and self._get_song(id=params['id'][0], send_icecast=send_icy_meta)

    def handle_song_info(self, params):
        info = self._get_song_info(params.get('id', ['~'])[0])
        return self.send_json_response(json.dumps(info))

    def handle_version(self, params):
        return self.send_json_response(server.json_version)

    def send_json_response(self, json_data):
        self._send_headers(200, 'application/json')
        self.wfile.write(json_data.encode('utf-8'))
        return True

    def handle_ifl_station(self, params):
        params['id'] = 'IFL'
        return self.get_station(params)

    def handle_album(self, params):
        if not 'id' in params:
            return False
        self._get_album(id=params['id'][0], params=params)
        return True

    def handle_top_tracks_artist(self, params):
        if not 'id' in params:
            return False
        self._get_all_lambda(params, lambda: self._get_top_tracks_artist(params))
        return True

    def handle_search_id(self, params):
        if not ('type' in params and ('title' in params or 'artist' in params)):
            return False
        self._send_headers(200)
        result = self._search(type=params.get('type', ['artist'])[0].lower().strip(), query_title=params['title'][0].decode(
            'latin-1') if 'title' in params else '', query_artist=params['artist'][0].decode('latin-1') if 'artist' in params else '', exact=params['exact'][0].lower().strip() if 'exact' in params else 'yes')
        if result:
            self.wfile.write(result)
        return True

    def handle_by_search(self, params):
        if not ('type' in params and ('title' in params or 'artist' in params)):
            return False
        p_type = params['type'][0].lower().strip()
        result = self._search(type=p_type, query_title=params.get('title', [''])[0],
                              query_artist=params.get('artist', [''])[0], exact=params.get('exact', ['no'])[0].lower().strip(),
                              max_results=params.get('num_tracks', [None])[0])
        if result and len(result) > 0:
            if p_type == 'artist':
                params['id'] = [result]
                self._get_all_lambda(params, lambda: self._get_top_tracks_artist(params))
            elif p_type == 'song':
                self._get_song(result)
            elif p_type == 'album':
                self._get_album(id=result, params=params)
            elif p_type == 'matches':
                self._get_all_lambda(params, lambda: result, tuple_function=match_to_track)
        return True

    def handle_new_station_by_id(self, params):
        if not ('id' in params and 'type' in params) or self._is_invalid_persistent(params):
            return False

        return self._get_all_lambda(params, lambda: self._get_new_station(params))

    def handle_new_station_by_search(self, params):
        if not ('type' in params and ('title' in params or 'artist' in params)) or self._is_invalid_persistent(params):
            return False
        s_type = params.get('type', ['artist'])[0].lower().strip()
        result = self._search(type=s_type, query_title=params.get('title', [''])[0],
                              query_artist=params.get('artist', [''])[0], exact=params.get('exact', ['no'])[0].lower().strip())
        if result and len(result) > 0:
            params['id'] = [result]
            self._get_all_lambda(params, lambda: self._get_new_station(params))
        return True

    def do_HEAD(self):
        self._process_request('HEAD', self.server.head_handlers)

    def _process_request(self, request_type, handlers):
        logger.debug('%s request path: %s', request_type, self.path)
        parsed_path = urlparse(self.path)
        params = parse_qs(parsed_path.query)
        params[gmputils.REQ_TYPE] = request_type
        params[gmputils.REQ_PATH] = parsed_path.path
        params[gmputils.REQ_URIINFO] = parsed_path
        dispatch = handlers.get(parsed_path.path, GetHandler._send_500)

        dispatch(self, params) or self._send_500(params)

    def send_empty_aa_response(self, params):
        logger.warning('This functionality requires an All Access subscription!')
        self._send_headers(200, 'audio/mpegurl', 'inline; filename=playlist.m3u')
        return True

    def _is_invalid_persistent(self, params):
        invalid = params.get('transient', [''])[0].lower().strip() == 'no' and (len(params.get('name', [''])[0]) == 0)
        if invalid:
            logger.warning('A new persistent station requires a name!')
        return invalid

    def _send_500(self, params):
        self._send_headers(500)
        logger.warning('Unknown command \'%s\' or missing required parameter!', params.get(gmputils.REQ_PATH))
        self.wfile.write(help_page.encode('utf-8'))
        return True

    def _send_headers(self, response_code=200, content_type=None, content_disposition=None, content_length=None, icy_metaint=None, icy_name=None):
        self.send_response(response_code)
        self._send_valid_header('Content-Type', content_type)
        self._send_valid_header('Content-Disposition', content_disposition)
        self._send_valid_header('Content-Length', content_length)
        self._send_valid_header('icy-metaint', icy_metaint)
        self._send_valid_header('icy-name', icy_name)
        self._send_valid_header('Access-Control-Allow-Origin', '*')
        self.end_headers()

    def _send_valid_header(self, h_name, h_value):
        if h_value:
            self.send_header(h_name, h_value)

    def _fetch_songs_list_cache(self):
        logger.debug('Fetching list of songs in collection')
        songs_list = self._robust_retry(lambda: api.get_all_songs())
        with self.server.lock:
            self.server.all_songs_cache.add_all_songs(songs_list)

    @staticmethod
    def _icy_name(album=None, artist=None, title=None):
        return '%s /// %s /// %s' % (artist, album, title)

    @staticmethod
    def _icy_metadata(album=None, artist=None, title=None):
        text = 'StreamTitle=\'%ss\';' % (GetHandler._icy_name(album, artist, title))
        metadata = (chr(len(text)) + text).ljust(len(text) * 16 + 1, chr(0))
        return metadata.encode('utf-8')

    def _get_song(self, id, only_headers=False, send_icecast=False):
        info = self._get_song_info(id)
        if info is None:
            logger.info('Streaming song with id \'%s\'', id)
            tagsBin = None
            tagsSize = 0
            songSize = 0
        else:
            logger.info('Streaming song with id \'%s\': %s - %s', id, info['artist'], info['title'])
            logger.debug(pprint.pformat(info))
            tags = eyed3.id3.Tag()
            tags.artist = info.get('artist', None)
            tags.album_artist = info.get('albumArtist', None)
            tags.album = info.get('album', None)
            tags.title = info.get('title', None)
            tags.track_num = info.get('trackNumber', None)
            tags.disc_num = info.get('discNumber', None)
            if 'genre' in info:
                tags.genre = eyed3.id3.Genre(info['genre'])
            if 'albumArtRef' in info:
                albumArt = opener.open(info['albumArtRef'][0]['url']).read()
                tags.images.set(3, albumArt, "image/jpeg")
            if 'year' in info and info['year']:
                tags.recording_date = int(info['year'])
            songSize = int(info.get('estimatedSize', 0))
            # weird hack: write the id3 tag on a temporary file and reload it
            # (no way to render it on memory...)
            tempFile = tempfile.NamedTemporaryFile(delete=False)
            tags.save(tempFile.name)
            tagsBin = tempFile.read()
            tagsSize = len(tagsBin)
            tempFile.close()
            os.unlink(tempFile.name)

        url = self._robust_retry(lambda: api.get_stream_url(song_id=id))
        logger.debug('streaming url: %s', url)

        do_shoutcast = config['shoutcast_metadata'] and send_icecast

        mp3 = opener.open(url)
        logger.debug('tag size: %s byte', tagsSize)
        logger.debug('content estimated size: %s byte', songSize)
        if mp3.info().get('Content-Length'):
            songSize = int(mp3.info().get('Content-Length'))
        logger.debug('content size from HTTP headers: %s byte', songSize)

        self._send_headers(200, 'audio/mpeg', 'inline; filename=%s.mp3' % id.strip(), ((tagsSize if not do_shoutcast else 0) + songSize) if (songSize > 0)
                           else None, downloadBlockSize if do_shoutcast else None, self._icy_name(tags.album, tags.artist, tags.title) if config['shoutcast_metadata'] else None)

        if only_headers:
            return True
        if tagsBin and not do_shoutcast:
            self.wfile.write(tagsBin)

        # prefill cache
        writtenBytes = 0
        block = mp3.read(downloadBlockSize)
        while len(block) > 0:
            self.wfile.write(block)
            writtenBytes += len(block)
            if do_shoutcast:
                imd = self._icy_metadata(tags.album, tags.artist, tags.title)
                logger.debug('Icy Metadata: %s', imd)
                self.wfile.write(imd)
            block = mp3.read(downloadBlockSize)
            if songSize > 0 and writtenBytes > cachePrefillSize and songSize - writtenBytes < maxCacheSize:
                break

        if not config['disable_playcount_increment']:
            logger.info('Increment playcount')
            self._robust_retry(lambda: api.increment_song_playcount(song_id=id))

        if songSize < 0:
            return True

        # consume the end of stream
        cache = bytearray(0)
        while len(block) > 0:
            cache.extend(block)
            block = mp3.read(downloadBlockSize)

        # serve from cache
        cacheSize = len(cache)
        position = 0
        while position < cacheSize:
            self.wfile.write(cache[position:position + min(cacheSize - position, downloadBlockSize)])
            position += downloadBlockSize
            if do_shoutcast:
                self.wfile.write(self._icy_metadata(tags.album, tags.artist, tags.title))
        return True

    def _get_song_info(self, id):
        info = self._get_from_cache(id)
        if info:
            return info
        if not config['disable_all_access'] and id[0] == 'T':
            new_song = self._add_to_cache(id)
            return new_song
        logger.error('Unsupported id \'%s\': report info to reproduce this to the author', id)

    def _add_to_cache(self, store_id):
        new_song = self._robust_retry(lambda: api.get_track_info(store_track_id=store_id))
        if new_song is None:
            return None
        with self.server.lock:
            self.server.all_songs_cache.add_song(new_song)
        return new_song

    def _get_from_cache(self, id):
        time_delta = datetime.datetime.now() - self.server.all_songs_cache.get_last_update()
        # update once an hour at the most
        if time_delta > datetime.timedelta(hours=1):
            logger.debug('Refreshing songs cache')
            self._fetch_songs_list_cache()
        return self.server.all_songs_cache.lookup_song(id)

    def get_all_stations(self, params):
        return self._get_all_lambda(params, api.get_all_stations, 'station', to_id_or_nid_track)

    def get_all_playlists(self, params):
        return self._get_all_lambda(params, api.get_all_playlists, 'playlist', to_id_or_share_token)

    def _get_all_lambda(self, params, gmusic_func, api_call='song', tuple_function=None):
        logger.debug('params: %s', params)
        results = self._robust_retry(gmusic_func)
        logger.debug(pprint.pformat(results))
        writer = gmputils.build_writer(server.host_and_port, api_call, params)
        if tuple_function is None:
            tuple_function = to_nid_track
        track_tuples = map(tuple_function, results)
        filtered = filter(lambda tid: tid[0] is not None, track_tuples)
        mime, file_extension, plist = writer.generate(filtered)
        logger.debug("gerated playlist:\n%s", plist)
        logger.debug('Getting all %ss as %s', api_call, mime)
        self._send_headers(200, mime, 'inline; filename=playlist.%s' % file_extension)
        self.wfile.write(plist.encode('utf-8'))
        return True

    def get_station(self, params):
        station_id = params.get('id', None)
        if station_id is None:
            return False
        numTracks = params.get('num_tracks', [defaultNumberTracksStation])[0]

        return self._get_all_lambda(params, lambda: api.get_station_tracks(
            station_id=station_id, num_tracks=numTracks))

    def _delete_transient(self, station_id, lock):
        transientStationIds.append(station_id)
        with lock:
            self._robust_retry(lambda: api.delete_stations(station_id))
            transientStationIds.remove(station_id)

    def _get_new_station(self, params):
        id = params['id'][0]
        type = params['type'][0].lower().strip()
        numTracks = params.get('num_tracks', [defaultNumberTracksStation])[0]
        transient = params.get('transient', ['yes'])[0].lower().strip() == 'yes'
        name = params.get('name', [transientStationName])[0]
        stationId = api.create_station(name=name, track_id=id if type == 'song' else None, artist_id=id if type ==
                                       'artist' else None, album_id=id if type == 'album' else None)  # by genre: TO DO
        lock = threading.Lock()
        with lock:
            if transient:
                t = threading.Thread(target=self._delete_transient, args=(stationId, lock,), daemon=True)
                t.start()
            station = api.get_station_tracks(station_id=stationId, num_tracks=numTracks)
        logger.info('Getting %s tracks from a new %s station based on %s id \'%s\'' % (
            numTracks, 'transient' if transient else 'persistent', type, id))
        return station

    def get_playlist(self, params):
        playlist_id = params.get('id', None)
        if playlist_id is None:
            return False
        playlist_id = playlist_id[0]
        logger.info('Getting tracks from playlist with id \'%s\'', playlist_id)
        shuffle = params.get('shuffle', [''])[0] == 'yes'

        target_playlist = None

        if playlist_id[0] == 'A' and playlist_id[1] == 'M':
            target_playlist = self._robust_retry(lambda: api.get_shared_playlist_contents(playlist_id))
            logger.debug(pprint.pformat(target_playlist))
        else:
            # we have to download the content of all the playlists (actual API
            # limitation)
            playlistsWithContents = self._robust_retry(lambda: api.get_all_user_playlist_contents())
            if logger.isEnabledFor(logging.DEBUG):
                logger.debug(pprint.pformat(playlistsWithContents))

            for playlist in playlistsWithContents:
                if playlist.get('id', '') == playlist_id:
                    target_playlist = playlist['tracks']

        if target_playlist is None:
            logger.warning("Playlist not found!")
            return False

        if shuffle:
            logger.info('Shuffling the playlist')
            random.shuffle(target_playlist)
        full_playlist = []
        for track in target_playlist:
            if 'trackId' in track:
                foundTrack = track.get('track', self.server.all_songs_cache.lookup_song(track['trackId']))
                if foundTrack:
                    full_playlist.append((track, foundTrack))
                else:
                    logger.warning(
                        "no information available in collection of track with id '%s'!", track['trackId'])
        return self._get_all_lambda(params, lambda: full_playlist, tuple_function=playlist_tuple_to_track)

    def _get_album(self, id, params):
        gfunc = lambda: api.get_album_info(
            album_id=id, include_tracks=True).get('tracks', {})

        return self._get_all_lambda(params, gfunc)

    def _get_top_tracks_artist(self, params):
        id = params['id'][0]
        numTracks = params.get('num_tracks', [defaultNumberTopTracks])[0]
        artist = api.get_artist_info(artist_id=id, include_albums=False,
                            max_top_tracks=numTracks, max_rel_artist=0)
        logger.info("Getting %s top tracks of the artist with id '%s': %s", numTracks, id, artist['name'])
        return artist.get('topTracks', {})

    def get_discography_artist(self, params):
        artist_id = params.get('id', [None])[0]
        logger.debug('get_discography_artist: %s', artist_id)
        if artist_id is None:
            return False
        return self._get_all_lambda(params, (lambda: api.get_artist_info(
            artist_id=artist_id, include_albums=True, max_top_tracks=0, max_rel_artist=0).get('albums', {})), 'album', to_albumid_track)

    def get_collection(self, params):
        ratingthreshold = params.get('rating', [0])[0]
        shuffle = params.get('shuffle', [''])[0] == 'yes'
        songs = self._robust_retry(lambda: api.get_all_songs())
        if len(songs) == 0:
            logger.warning("No songs in your collection!?!")
            return True

        if ratingthreshold > 0:
            logger.info('Filtering out songs with rating lower than %s', ratingthreshold)
            for song in songs:
                songrating = song.get('rating', ratingthreshold)
                if int(songrating) < ratingthreshold:
                    songs.remove(song)

        if shuffle:
            logger.info('Shuffling the collection')
            random.shuffle(songs)

        logger.info('Getting your collection: %s tracks', len(songs))
        return self._get_all_lambda(params, lambda: songs, tuple_function=to_id_or_nid_track)

    def _search(self, type, query_title, query_artist, exact, max_results=None):
        if type is None or type not in ['artist', 'song', 'album', 'matches']:
            logger.warning('The type of search has to be specified: artist, song, album or matches!')
            return
        logger.info('Searching for %s with query: %s %s', type, query_artist, query_title)
        not_exact = exact != 'yes'
        if type == 'artist':
            match = self._search_for_match(query_artist, '', 'artist_hits', not_exact, matches_artist)
            if match and 'artist' in match and 'artistId' in match['artist']:
                logger.info('Selected artist: %s (%s)', match['artist'][
                            'name'], match['artist']['artistId'])
                logger.debug(pprint.pformat(match))
                return match['artist']['artistId']
            else:
                logger.warning('No matching found.')
        elif type == 'song':
            match = self._search_for_match(query_artist, query_title, 'song_hits', not_exact, matches_artist_title)
            if match and 'track' in match and 'storeId' in match['track']:
                logger.info('Selected song: %s - %s (%s)', match['track'][
                            'artist'], match['track']['title'], match['track']['storeId'])
                logger.debug(pprint.pformat(match))
                return match['track']['storeId']
            else:
                logger.warning('No matching found.')
        elif type == 'matches':
            results = self._robust_retry(lambda: api.search(
                '%s %s' % (query_artist, query_title), max_results))
            logger.debug(pprint.pformat(results))
            match = results['song_hits']
            if match:
                return match
            else:
                logger.warning('No matching found.')
        elif type == 'album':
            match = self._search_for_match(query_artist, query_title, 'album_hits', not_exact, matches_album_artist)
            if match and 'album' in match and 'albumId' in match['album']:
                logger.info('Selected album: %s - %s (%s)', match['album'][
                            'artist'], match['album']['name'], match['album']['albumId'])
                logger.debug(pprint.pformat(match))
                return match['album']['albumId']
            else:
                logger.warning('No matching found.')
        else:
            return

    def _search_for_match(self, query_artist, query_title, result_key, not_exact, match_func):
        search_string = ('%s %s' % (query_artist, query_title)).strip()
        results = self._robust_retry(lambda: api.search(search_string))
        logger.debug(pprint.pformat(results))
        if not_exact and result_key in results and len(results[result_key]) > 0:
            logger.debug('I\'m feeling lucky: lets select the first album in list!')
            return results[result_key][0]
        else:
            if result_key in results:
                lc_title = query_title.lower().strip()
                lc_artist = query_artist.lower().strip()
                for result in results[result_key]:
                    if match_func(result, lc_artist, lc_title):
                        logger.debug('Found exact %s match in list!', result_key)
                        return result

    def rate_song(self, params):
        song_id = params.get('id', None)
        if song_id is None:
            return False

        rating = 5 if params.get(self.REQ_PATH) == '/like_song' else 1
        info = self.server.all_songs_cache.lookup_song(song_id)
        if info is None and song_id[0] == 'T':
            info = self._add_to_cache(song_id)
        else:
            logger.error('Unsupported id \'%s\': report info to reproduce this to the author', song_id)
        if info is None:
            logger.warning('Song with id \'%s\' not found.', song_id)
        else:
            logger.info('Reporting rating=%s on song with id \'%s\': %s - %s',
                        rating, song_id, info['artist'], info['title'])
            logger.debug(pprint.pformat(info))
            info['rating'] = rating
            self._robust_retry(lambda: api.change_song_metadata([info]))
        return True

    @gmusicapi.utils.utils.retry(retry_exception=requests.exceptions.ConnectionError)
    def _robust_retry(self, func):
        return func()

    def handle_one_request(self):
        try:
            BaseHTTPRequestHandler.handle_one_request(self)
        except CallFailure as e:
            if '401 Client Error: Unauthorized' in e.message and config['device_id'] != '**auto**':
                logger.warning(
                    'Server denied authorization, trying to reconnect...')
                api.logout()
                if config['email'] is not None or config['password'] is not None:
                    api.login(config['email'], config['password'], config['device_id'])
                else:
                    api.oauth_login(config['device_id'])
                if api.is_authenticated():
                    self.handle_one_request()
                else:
                    logger.error('Sorry, could not reconnect, those credentials weren\'t accepted.')
                    sys.exit(1)
            else:
                raise
        except socket.error as e:
            if e[0] == errno.ECONNRESET:
                logger.warning('Detected connection reset.')
            elif e[0] == errno.EPIPE:
                logger.warning('Detected remote peer disconnected.')
            elif e[0] == 10053:
                logger.warning(
                    'An established connection was aborted by the software in your host machine.')
            else:
                raise

    def finish(self, *args, **kw):
        # fix from http://stackoverflow.com/a/14355079/1834797
        try:
            if not self.wfile.closed:
                self.wfile.flush()
                self.wfile.close()
        except socket.error:
            pass
        self.rfile.close()


def matches_artist(result, artist, title):
    return result['artist'].get('name', '').lower().strip() == artist


def matches_artist_title(result, artist, title):
    return result['track'].get('title', '').lower().strip() == title and \
           result['track'].get('artist', '').lower().strip() == artist


def matches_album_artist(result, artist, title):
    return result['album'].get('name', '').lower().strip() == title and \
           result['album'].get('artist', '').lower().strip() == artist


def to_id_or_share_token(track):
    id_or_st = 'shareToken' if track.get('type', '') == 'SHARED' else 'id'
    return track[id_or_st], track


def to_nid_track(track):
    return track.get('nid'), track


def to_id_or_nid_track(track):
    id_or_nid = track.get('id', track.get('nid', None))
    return id_or_nid, track


def match_to_track(song):
    track = song['track']
    return track.get('storeId'), track


def playlist_tuple_to_track(p_tuple):
    track = p_tuple[0]
    return track['trackId'], p_tuple[1]


def to_albumid_track(album):
    return album.get('albumId'), album


def config_handlers(http_server):
        http_server.get_handlers = {
            '/get_song': GetHandler.handle_song,
            '/get_song_info': GetHandler.handle_song_info,
            '/get_all_stations': GetHandler.get_all_stations,  # aa
            '/get_all_playlists': GetHandler.get_all_playlists,
            '/get_station': GetHandler.get_station,  # aa
            '/get_ifl_station': GetHandler.handle_ifl_station,  # aa
            '/get_playlist': GetHandler.get_playlist,
            '/get_album': GetHandler.handle_album,  # aa
            '/get_top_tracks_artist': GetHandler.handle_top_tracks_artist,  # aa
            '/get_discography_artist': GetHandler.get_discography_artist,  # aa
            '/get_collection': GetHandler.get_collection,
            '/search_id': GetHandler.handle_search_id,  # aa
            '/get_by_search': GetHandler.handle_by_search,  # aa
            '/get_new_station_by_id': GetHandler.handle_new_station_by_id,  # aa
            '/get_new_station_by_search': GetHandler.handle_new_station_by_search,  # aa
            '/like_song': GetHandler.rate_song,
            '/dislike_song': GetHandler.rate_song,
            '/get_version': GetHandler.handle_version
        }
        http_server.head_handlers = {
            '/get_song': GetHandler.handle_song
        }

        if config['disable_all_access']:
            for path in http_server.ALL_ACCESS:
                http_server.get_handlers[path] = GetHandler.send_empty_aa_response


def signalHandler(signal, frame):
    logger.info('Shutting down the proxy...')
    if server:
        server.socket.close()
    if len(transientStationIds) and api:
        api.delete_stations(transientStationIds)
    if api:
        api.logout()
    if opener:
        opener.close()
    sys.exit()


def getOptions(filename):
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--config', type=open,
                        help='specific configuration file to use')
    parser.add_argument(
        '-e', '--email', help='[DEPRECATED] email address of the Google account')
    parser.add_argument(
        '-p', '--password', help='[DEPRECATED] password of the Google account (or an application-specific one if two-factor authentication is enabled)')
    parser.add_argument(
        '-d', '--device-id', help='the ID of a registered Android/iOS device [default: fake-id based on mac address of network card]')
    parser.add_argument(
        '-H', '--host', help='host in the generated URLs [default: autodetected local ip address]')
    parser.add_argument(
        '-b', '--bind-address', help='ip address to bind to [default: 0.0.0.0=all]')
    parser.add_argument('-P', '--port', type=int,
                        help='default TCP port to use [default: 9999]')
    parser.add_argument('-a', '--disable-all-access', default=False,
                        action='store_true', help='disable All Access functionalities')
    parser.add_argument('-L', '--list-devices', default=False,
                        action='store_true', help='list the registered devices')
    parser.add_argument('-D', '--debug', default=False,
                        action='store_true', help='enable debug messages')
    parser.add_argument('-l', '--log', help='log file')
    parser.add_argument('-f', '--daemon', default=False,
                        action='store_true', help='daemonize the program')
    parser.add_argument('-v', '--disable-version-check', default=False,
                        action='store_true', help='disable check for latest available version')
    parser.add_argument('-x', '--extended-m3u', default=False,
                        action='store_true', help='enable non-standard extended m3u headers')
    parser.add_argument('-s', '--shoutcast-metadata', default=False, action='store_true',
                        help='enable Shoutcast metadata protocol support (disabling IDv3 tags)')
    parser.add_argument('-C', '--disable-playcount-increment', default=False, action='store_true',
                        help='disable the automatic increment of playcounts upon song fetch')
    parser.add_argument(
        '--keyring-backend', help='[DEPRECATED] name of the keyring backend to use instead of the default one')
    parser.add_argument('--list-keyring-backends', default=False,
                        action='store_true', help='[DEPRECATED] list the available keyring backends')
    parser.add_argument(
        '--keyring-service', help='[DEPRECATED] keyring service to use, takes precedence over --password if set')
    parser.add_argument(
        '--keyring-entry', help='[DEPRECATED] keyring entry to use, required if --keyring-service is used')

    gmp_config = ConfigParser()
    args = parser.parse_args()
    fp = StringIO('[dummy]\n')
    gmp_config.read_file(fp)
    if args.config:
        fp = StringIO('[dummy]\n' + args.config.read())
        gmp_config.read_file(fp)
    else:
        for path in reversed(list(xdg.BaseDirectory.load_config_paths(filename))):
            fp = StringIO('[dummy]\n' + open(path, 'r').read())
            gmp_config.read_file(fp)
    config_values = dict(gmp_config.items('dummy'))

    # adjust some names in order to make work configparser with argparse
    for key in list(config_values.keys()):
        if '-' in key:
            config_values[key.replace('-', '_')] = config_values.pop(key)

    if 'bind_address' in config_values and 'host' not in config_values:
        config_values['host'] = config_values['bind_address']

    # some defaults
    if 'bind_address' not in config_values:
        config_values['bind_address'] = '0.0.0.0'
    if 'host' not in config_values:
        config_values['host'] = '**auto**'
    if 'port' not in config_values:
        config_values['port'] = '9999'
    if 'device_id' not in config_values:
        config_values['device_id'] = '**auto**'

    parser.set_defaults(**config_values)
    args = parser.parse_args()
    gmp_config = vars(args)
    return gmp_config


def listDevices():
    devices = api.get_registered_devices()
    if len(devices) == 0:
        logger.warning(
            'No Android or iOS devices registered in your Google account.')
    else:
        api.logout()
        for d in devices:
            if d['type'] == 'ANDROID' or d['type'] == 'IOS':
                logger.info('- %s --> device-id=%s', d['friendlyName'] if d['friendlyName'] is not None and len(
                    d['friendlyName']) > 0 else '(None)', d['id'].replace('0x', ''))
        sys.exit()


def loginGM(device_id=gmusicapi.Mobileclient.FROM_MAC_ADDRESS, email=None, password=None):
    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
    api = gmusicapi.Mobileclient(debug_logging=config['debug'])
    if config['debug']:
        api.logger = logger
    if email is not None or password is not None:
        api.login(email, password, device_id)
        if not api.is_authenticated():
            logger.error('Sorry, credentials weren\'t accepted.')
            logger.error('Does your account have Two Factor Authentication (2FA) enabled?')
            logger.error('If so, you must create and use an App Password in your account settings')
            logger.error('Please consider switching to OAuth2 credentials.')
            sys.exit(1)
    else:
        if not api.oauth_login(device_id):
            api.perform_oauth(open_browser=True)
            if not api.oauth_login(device_id):
                logger.error('Failed to login with OAuth2 credentials.')
                sys.exit(1)
    return api

def autodetectLocalIP():
    interfaces = reversed(netifaces.interfaces())
    for i in interfaces:
        if i == 'lo':
            continue
        iface = netifaces.ifaddresses(i).get(netifaces.AF_INET)
        if iface is not None:
            for j in iface:
                return j['addr']
    return '127.0.0.1'

def checkLatestVersion():
    logger.debug('Fetching lastest version of %s from %s', programName, urlLatestVersion)
    try:
        version_map = requests.get(urlLatestVersion).json()
        logger.debug('version info is %s', version_map)
        latest_version = version_map.get('version')
        logger.debug('latest available version: %s', latest_version)
        logger.debug('installed version: %s', programVersion)
        if latest_version == '':
            raise ValueError
        if distutils.version.StrictVersion(programVersion) < distutils.version.StrictVersion(latest_version):
            logger.warning('There is a new %s release of %s. Consider the idea to update your '
                           'installation in order to keep it working!\n', latest_version, programName)
    except requests.exceptions.HTTPError as http_err:
        logger.warn('Error in fetching version information %s', http_err)
    except ValueError:
        logger.debug('Error on malformed version data (\'%s\', \'%s\')',
                     latest_version, programVersion)


def checkKeyringModule():
    if not 'keyring' in globals():
        logger.error('Python \'keyring\' module is not available!\nPlease consult '
                     'https://pypi.python.org/pypi/keyring#installation-instructions to use keyring feature')
        sys.exit(1)


def getKeyringPassword():
    checkKeyringModule()
    try:
        if config['keyring_backend']:
            keyring.set_keyring(keyring.load_keyring(
                config['keyring_backend']))

        if config['keyring_service'] is None or config['keyring_entry'] is None:
            logger.error('Please, specify both keyring service and keyring entry in the config file '
                         'or on the command-line to use keyring feature.')
            sys.exit(1)

        password = keyring.get_password(
            config['keyring_service'], config['keyring_entry'])
        if password is None:
            logger.error('No password is stored in entry \'%s\' of service \'%s\'', config[
                         'keyring_entry'], config['keyring_service'])

        return password
    except Exception as e:
        logger.error('Failed to access keyring: %s', e.message)
        sys.exit(1)


def listKeyringBackends():
    checkKeyringModule()
    logger.info('Available keyring backends:')
    for backend in keyring.backend.get_all_keyring():
        logger.info('    %s.%s', type(backend).__module__,
                    type(backend).__name__)
    sys.exit()


if __name__ == '__main__':
    downloadBlockSize = 16 * 1024
    cachePrefillSize = 60 * 320/8 * 1024 # 60 seconds at 320 kbit/s
    maxCacheSize = 180 * 320/8 * 1024 # 180 seconds
    defaultNumberTracksStation = 50
    defaultNumberTopTracks = 20
    programDescription = 'Google Play Music Proxy'
    programName = 'gmusicproxy'
    programVersion = '2.1.0'
    configFilename = '%s.cfg' % programName
    transientStationName = '%s station ' % programDescription
    transientStationIds = []
    urlLatestVersion = 'https://gmusicproxy.github.io/version.json'

    # remove previous root logging handler
    logger = logging.getLogger()
    list(map(logger.removeHandler, logger.handlers[:]))

    # initial setup of my logger
    logger = logging.getLogger(programName)
    logger.setLevel(logging.INFO)
    consoleHandler = logging.StreamHandler(sys.stdout)
    consoleHandler.setFormatter(logging.Formatter('%(message)s'))
    logger.addHandler(consoleHandler)

    config = getOptions(configFilename)

    # complete setup of the logger
    fileHandler = None
    if config['log']:
        fileHandler = logging.FileHandler(config['log'], encoding='utf-8')
        logger.addHandler(fileHandler)
    if config['debug']:
        logger.setLevel(logging.DEBUG)
        if fileHandler:
            fileHandler.setFormatter(logging.Formatter(
                '[%(levelname)s] (%(module)s:%(lineno)s): %(message)s'))

    logger.info('%s %s\n', programDescription, programVersion)

    # preliminar setup for the daemonaization
    if config['daemon']:
        if os.name == 'nt':
            logger.error('Daemon-mode is not supported under Windows!')
            sys.exit(1)
        if not 'daemon' in globals():
            logger.error('Python \'daemon\' module is not installed!')
            sys.exit(1)
        context_daemon = daemon.DaemonContext(files_preserve=[])
        # python-daemon>=2.1 has initgroups=True by default but it requires root privs
        # older versions don't support initgroups as constructor parameter so
        # we set it manually instead
        context_daemon.initgroups = False
        if fileHandler:
            context_daemon.files_preserve.append(fileHandler.stream)
        consoleHandler.setLevel(logging.ERROR)

    safeConfig = config.copy()
    safeConfig['password'] = '***OMITTED***'   # for debug dump
    logger.debug('configuration used:\n%s\n', pprint.pformat(safeConfig))

    if config['keyring_service'] is not None or config['keyring_entry'] is not None:
        config['password'] = getKeyringPassword()

    if config['email'] is not None or config['password'] is not None:
        logger.warning('Email and password based login is deprecated. Please switch to OAuth2. See README for more details.')

    api = loginGM(gmusicapi.Mobileclient.FROM_MAC_ADDRESS if config[
                  'device_id'] == '**auto**' else config['device_id'],
                  email=config['email'], password=config['password'])

    with open("README.md", "r") as read_me:
        gmp_md = ''.join(read_me.readlines())
    help_page = markdown.markdown(gmp_md)
    help_page = "<!DOCTYPE html><html lang='en'><head><title>GMusicProxy</title></head><body>" + help_page + "</body></html>"

    if config['list_devices']:
        listDevices()

    if config['list_keyring_backends']:
        listKeyringBackends()

    if config['host'] == '**auto**':
        config['host'] = autodetectLocalIP()

    opener = build_opener()
    opener.addheaders = [('User-agent', '%s %s' %
                          (programDescription, programVersion))]

    signal.signal(signal.SIGINT, signalHandler)

    if not config['disable_version_check']:
        checkLatestVersion()

    server = MultiThreadedHTTPServer(
        (config['bind_address'], config['port']), GetHandler)

    server.lock = threading.Lock()
    server.all_songs_cache = gmputils.GMSongsCache(logger)
    server.host_and_port = '%s:%s' % (config['host'], config['port'])
    server.json_version = json.dumps({"version": programVersion})
    config_handlers(server)

    logger.info('Listening on %s:%s...', config['bind_address'], config['port'])

    if config['daemon']:
        context_daemon.files_preserve.append(server.fileno())
        with context_daemon:
            server.serve_forever()
    else:
        server.serve_forever()
